# ClipPal è½»é‡çº§æ¸è¿›å¼é‡æ„æ–¹æ¡ˆ

## æ–‡æ¡£ä¿¡æ¯
- **ç‰ˆæœ¬**: v2.0
- **æ—¥æœŸ**: 2025-12-03
- **ä½œè€…**: ClipPal Team
- **çŠ¶æ€**: å¾…è¯„å®¡

---

## ç›®å½•
- [ä¸€ã€æ–¹æ¡ˆæ¦‚è¿°](#ä¸€æ–¹æ¡ˆæ¦‚è¿°)
- [äºŒã€ç°çŠ¶åˆ†æ](#äºŒç°çŠ¶åˆ†æ)
- [ä¸‰ã€ç›®æ ‡æ¶æ„](#ä¸‰ç›®æ ‡æ¶æ„)
- [å››ã€æ ¸å¿ƒæ”¹è¿›ç‚¹](#å››æ ¸å¿ƒæ”¹è¿›ç‚¹)
- [äº”ã€è¯¦ç»†è®¾è®¡](#äº”è¯¦ç»†è®¾è®¡)
- [å…­ã€å®æ–½è·¯çº¿å›¾](#å…­å®æ–½è·¯çº¿å›¾)
- [ä¸ƒã€æ–¹æ¡ˆå¯¹æ¯”](#ä¸ƒæ–¹æ¡ˆå¯¹æ¯”)
- [å…«ã€é£é™©ä¸åº”å¯¹](#å…«é£é™©ä¸åº”å¯¹)

---

## ä¸€ã€æ–¹æ¡ˆæ¦‚è¿°

### 1.1 è®¾è®¡ç†å¿µ

æœ¬æ–¹æ¡ˆé‡‡ç”¨**è½»é‡çº§æ¸è¿›å¼é‡æ„**ç­–ç•¥ï¼Œåœ¨ä¸å¼•å…¥è¿‡åº¦å¤æ‚æ€§çš„å‰æä¸‹ï¼Œè§£å†³å½“å‰æ¶æ„çš„æ ¸å¿ƒé—®é¢˜ã€‚

**æ ¸å¿ƒåŸåˆ™ï¼š**
- ğŸ¯ **èšç„¦é—®é¢˜** - åªè§£å†³çœŸæ­£å­˜åœ¨çš„é—®é¢˜
- ğŸ“¦ **ç®€å•ä¼˜å…ˆ** - é¿å…è¿‡åº¦è®¾è®¡
- ğŸ”„ **æ¸è¿›è¿­ä»£** - åˆ†é˜¶æ®µå®æ–½ï¼Œä¿æŒç³»ç»Ÿå¯è¿è¡Œ
- ğŸ’° **æˆæœ¬å¯æ§** - ä»£ç é‡å¢åŠ æ§åˆ¶åœ¨30%ä»¥å†…

### 1.2 ä¸ºä»€ä¹ˆä¸ç”¨å®Œæ•´DDDï¼Ÿ

| è€ƒè™‘å› ç´  | å®Œæ•´DDD | æœ¬æ–¹æ¡ˆ |
|---------|---------|--------|
| **é¡¹ç›®è§„æ¨¡** | é€‚åˆå¤§å‹ç³»ç»Ÿ | âœ… é€‚åˆä¸­å°å‹ç³»ç»Ÿ |
| **å›¢é˜Ÿè§„æ¨¡** | éœ€è¦10+å¼€å‘è€… | âœ… é€‚åˆå°å›¢é˜Ÿ/ä¸ªäºº |
| **é¢†åŸŸå¤æ‚åº¦** | éœ€è¦å¤æ‚ä¸šåŠ¡è§„åˆ™ | âœ… ä¸šåŠ¡é€»è¾‘ç›¸å¯¹ç®€å• |
| **å¼€å‘å‘¨æœŸ** | 1-2ä¸ªæœˆ | âœ… 2-3å‘¨ |
| **ä»£ç å¢é‡** | +70% | âœ… +30% |
| **å­¦ä¹ æ›²çº¿** | é™¡å³­ | âœ… å¹³ç¼“ |

### 1.3 æ–¹æ¡ˆæ”¶ç›Š

| æ”¹è¿›é¡¹ | å½“å‰çŠ¶æ€ | æ”¹è¿›å |
|--------|---------|--------|
| **å®ä½“å°è£…** | è´«è¡€æ¨¡å‹ï¼Œæ‰€æœ‰å­—æ®µpublic | å……è¡€æ¨¡å‹ï¼Œç§æœ‰å­—æ®µ+è¡Œä¸ºæ–¹æ³• |
| **æ•°æ®è®¿é—®** | ä¸šåŠ¡å±‚ç›´æ¥ä½¿ç”¨RBatis | Repositoryå±‚éš”ç¦» |
| **ä¾èµ–ç®¡ç†** | å…¨å±€CONTEXTï¼Œ73å¤„å¼•ç”¨ | ä¾èµ–æ³¨å…¥ï¼Œæ˜ç¡®ä¾èµ–å…³ç³» |
| **ä¸šåŠ¡é€»è¾‘** | æ•£è½åœ¨é™æ€æ–¹æ³•ä¸­ | é›†ä¸­åœ¨Serviceå±‚ |
| **ç”¨æˆ·çŠ¶æ€** | åˆ°å¤„è°ƒç”¨VipCheckerï¼Œæ— ç¼“å­˜ | ç»Ÿä¸€çŠ¶æ€ç®¡ç†+äº‹ä»¶é©±åŠ¨ |
| **å¯æµ‹è¯•æ€§** | éš¾ä»¥Mockå’Œå•å…ƒæµ‹è¯• | æ˜“äºæµ‹è¯•ï¼Œå¯Mockä¾èµ– |
| **æ¨¡å—è€¦åˆ** | é«˜è€¦åˆï¼Œå•æ–‡ä»¶ä¾èµ–10+æ¨¡å— | ä½è€¦åˆï¼Œæ¸…æ™°çš„åˆ†å±‚ |

---

## äºŒã€ç°çŠ¶åˆ†æ

### 2.1 å½“å‰æ¶æ„é—®é¢˜

#### é—®é¢˜1ï¼šè´«è¡€é¢†åŸŸæ¨¡å‹ï¼ˆæœ€ä¸¥é‡ï¼‰

**å½“å‰ä»£ç ï¼š** `src-tauri/src/biz/clip_record.rs`

```rust
// âŒ é—®é¢˜ä»£ç 
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
pub struct ClipRecord {
    pub id: String,              // âŒ æ‰€æœ‰å­—æ®µpublic
    pub r#type: String,          // âŒ ä½¿ç”¨Stringè€Œéæšä¸¾
    pub content: Value,
    pub md5_str: String,
    pub created: u64,            // âŒ ä½¿ç”¨åŸå§‹ç±»å‹
    pub pinned_flag: i32,        // âŒ å‘½åä¸æ¸…æ™°
    pub sync_flag: Option<i32>,  // âŒ åº”è¯¥ç”¨æšä¸¾
    // ... æ›´å¤šå­—æ®µ
}

impl ClipRecord {
    // âŒ å…¨æ˜¯é™æ€æ–¹æ³•ï¼Œéœ€è¦ä¼ RBatis
    pub async fn update_pinned(rb: &RBatis, id: &str, pinned_flag: i32) -> AppResult<()> {
        // ...
    }
    // ... 20+ä¸ªé™æ€æ–¹æ³•
}
```

#### é—®é¢˜2ï¼šå…¨å±€çŠ¶æ€æ³›æ»¥

```rust
// âŒ CONTEXTåœ¨20ä¸ªæ–‡ä»¶ä¸­ä½¿ç”¨ï¼Œå…±73å¤„å¼•ç”¨
pub static CONTEXT: TypeMap![Send + Sync] = <TypeMap![Send + Sync]>::new();

// ä½¿ç”¨ç¤ºä¾‹ï¼ˆåˆ°å¤„éƒ½æ˜¯ï¼‰
let rb: &RBatis = CONTEXT.get::<RBatis>();
let app_handle = CONTEXT.get::<AppHandle>();
```

#### é—®é¢˜3ï¼šæ•°æ®è®¿é—®æ··ä¹±

```rust
// âŒ ä¸šåŠ¡é€»è¾‘ä¸æ•°æ®è®¿é—®æ··åˆ
pub async fn sync_clipboard() -> AppResult<()> {
    let rb: &RBatis = CONTEXT.get::<RBatis>();
    let records = ClipRecord::select_all(rb).await?;
    // ...
}
```

#### é—®é¢˜4ï¼šæ¨¡å—é«˜è€¦åˆ

```rust
// âŒ å•ä¸ªæ–‡ä»¶ä¾èµ–10+ä¸ªæ¨¡å—
use crate::biz::vip_checker::VipChecker;
use crate::CONTEXT;
// ... æ›´å¤šä¾èµ–
```

#### é—®é¢˜5ï¼šVIPçŠ¶æ€æ£€æŸ¥æ··ä¹±ï¼ˆæ–°è¯†åˆ«çš„é—®é¢˜ï¼‰â­

**å½“å‰ä»£ç é—®é¢˜ï¼š**

```rust
// âŒ é—®é¢˜1ï¼šåˆ°å¤„è°ƒç”¨æ£€æµ‹æ–¹æ³•ï¼ˆ10ä¸ªæ–‡ä»¶ä¸­ä½¿ç”¨ï¼‰
// cloud_sync_timer.rs
match VipChecker::is_vip_user().await {
    // ...
}

// upload_cloud_timer.rs
match VipChecker::check_cloud_sync_permission().await {
    // ...
}

// system_setting.rs
match VipChecker::check_cloud_sync_permission().await {
    // ...
}

// âŒ é—®é¢˜2ï¼šæ¯æ¬¡è°ƒç”¨éƒ½å¯èƒ½è§¦å‘APIè¯·æ±‚ï¼ˆvip_checker.rs:35ï¼‰
pub async fn is_vip_user() -> AppResult<bool> {
    match user_vip_check().await {  // ç½‘ç»œè¯·æ±‚
        // ...
    }
}

// âŒ é—®é¢˜3ï¼šçŠ¶æ€å˜æ›´å¤„ç†ç¡¬ç¼–ç ï¼ˆvip_checker.rs:58-61ï¼‰
if vip_changed {
    log::info!("æ£€æµ‹åˆ°VIPçŠ¶æ€å˜åŒ–ï¼Œå¤„ç†è·³è¿‡çš„è®°å½•");
    Self::update_skipped_records_after_vip_change(&vip_response).await?;
}
```

**è°ƒç”¨ç»Ÿè®¡ï¼š**
- `VipChecker::is_vip_user()` - åœ¨5ä¸ªæ–‡ä»¶ä¸­è°ƒç”¨
- `VipChecker::check_cloud_sync_permission()` - åœ¨4ä¸ªæ–‡ä»¶ä¸­è°ƒç”¨
- æ¯æ¬¡è°ƒç”¨éƒ½å¯èƒ½è§¦å‘ç½‘ç»œè¯·æ±‚
- æ— ç¼“å­˜æœºåˆ¶ï¼Œæ€§èƒ½æµªè´¹
- çŠ¶æ€å˜æ›´é€»è¾‘ç¡¬ç¼–ç ï¼Œéš¾ä»¥æ‰©å±•

### 2.2 ä¸ºä»€ä¹ˆè¿™äº›é—®é¢˜éœ€è¦è§£å†³ï¼Ÿ

| é—®é¢˜ | å½“å‰å½±å“ | æœªæ¥é£é™© |
|-----|---------|---------|
| **è´«è¡€æ¨¡å‹** | ä¸šåŠ¡é€»è¾‘åˆ†æ•£ï¼Œéš¾ä»¥ç†è§£ | éšç€åŠŸèƒ½å¢åŠ ï¼Œä»£ç ä¼šè¶Šæ¥è¶Šæ··ä¹± |
| **å…¨å±€çŠ¶æ€** | å¹¶å‘é—®é¢˜ï¼Œéš¾ä»¥æµ‹è¯• | å®¹æ˜“å‡ºç°éš¾ä»¥è°ƒè¯•çš„bug |
| **æ•°æ®è®¿é—®æ··ä¹±** | ä¸šåŠ¡é€»è¾‘ä¸æŠ€æœ¯ç»†èŠ‚æ··åˆ | æ— æ³•åˆ‡æ¢æ•°æ®åº“æˆ–Mockæµ‹è¯• |
| **é«˜è€¦åˆ** | ä¿®æ”¹ä¸€å¤„å½±å“å¤šå¤„ | æŠ€æœ¯å€ºç´¯ç§¯ï¼Œç»´æŠ¤æˆæœ¬æš´å¢ |
| **VIPæ£€æŸ¥æ··ä¹±** | æ€§èƒ½æµªè´¹ï¼ˆé¢‘ç¹APIè°ƒç”¨ï¼‰ | çŠ¶æ€ä¸ä¸€è‡´ã€æ‰©å±•å›°éš¾ |

---

## ä¸‰ã€ç›®æ ‡æ¶æ„

### 3.1 æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Frontend (Tauri UI)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“ (invoke commands)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Commands å±‚ï¼ˆTauriæ¥å£ï¼‰                          â”‚
â”‚  - clipboard_commands.rs                                     â”‚
â”‚  - user_commands.rs                                          â”‚
â”‚  - sync_commands.rs                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Services å±‚ï¼ˆä¸šåŠ¡æœåŠ¡ï¼‰                          â”‚
â”‚  - ClipboardService                                          â”‚
â”‚  - SyncService                                               â”‚
â”‚  - UserService                                               â”‚
â”‚  - VipService                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Repositories å±‚    â”‚    â”‚   UserStateManager + EventBus   â”‚
â”‚  (æ•°æ®è®¿é—®)         â”‚    â”‚   (çŠ¶æ€ç®¡ç† + äº‹ä»¶é©±åŠ¨) â­        â”‚
â”‚                    â”‚    â”‚                                 â”‚
â”‚ - ClipboardRepo    â”‚    â”‚ - ç»Ÿä¸€ç™»å½•/VIPçŠ¶æ€              â”‚
â”‚ - UserRepo         â”‚    â”‚ - æ™ºèƒ½ç¼“å­˜ï¼ˆ5åˆ†é’ŸTTLï¼‰           â”‚
â”‚ - SettingsRepo     â”‚    â”‚ - äº‹ä»¶å‘å¸ƒ/è®¢é˜…                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                          â”‚
         â†“                          â†“ (è®¢é˜…äº‹ä»¶)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Domain å±‚          â”‚   â”‚     Event Handlers           â”‚
â”‚  (é¢†åŸŸæ¨¡å‹)          â”‚   â”‚  - CloudSyncHandler          â”‚
â”‚                     â”‚   â”‚  - RecordLimitHandler        â”‚
â”‚ - ClipRecord        â”‚   â”‚  - UINotificationHandler     â”‚
â”‚ - User              â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ - VipMembership     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¾èµ–è§„åˆ™ï¼š**
- Commands â†’ Services â†’ Repositories â†’ Domain
- Services â†’ UserStateManagerï¼ˆè·å–çŠ¶æ€ï¼‰
- UserStateManager â†’ EventBusï¼ˆå‘å¸ƒäº‹ä»¶ï¼‰
- EventHandlers â† EventBusï¼ˆè®¢é˜…äº‹ä»¶ï¼‰

### 3.2 ç›®å½•ç»“æ„

```
src-tauri/src/
â”œâ”€â”€ main.rs                     # ç¨‹åºå…¥å£
â”œâ”€â”€ lib.rs                      # å¯åŠ¨é…ç½® + ä¾èµ–æ³¨å…¥
â”‚
â”œâ”€â”€ domain/                     # é¢†åŸŸæ¨¡å‹ï¼ˆè½»é‡çº§ï¼‰
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ clipboard.rs            # ClipRecordå®ä½“ï¼ˆå……è¡€æ¨¡å‹ï¼‰
â”‚   â”œâ”€â”€ user.rs                 # Userå®ä½“
â”‚   â”œâ”€â”€ vip.rs                  # VipInfoå®ä½“
â”‚   â””â”€â”€ types.rs                # é€šç”¨ç±»å‹å’Œç®€å•å€¼å¯¹è±¡
â”‚
â”œâ”€â”€ repository/                 # æ•°æ®è®¿é—®å±‚
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ clipboard_repo.rs       # å‰ªè´´æ¿æ•°æ®è®¿é—®
â”‚   â”œâ”€â”€ user_repo.rs            # ç”¨æˆ·æ•°æ®è®¿é—®
â”‚   â””â”€â”€ settings_repo.rs        # è®¾ç½®æ•°æ®è®¿é—®
â”‚
â”œâ”€â”€ service/                    # ä¸šåŠ¡æœåŠ¡å±‚
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ clipboard_service.rs    # å‰ªè´´æ¿ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ sync_service.rs         # åŒæ­¥ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ user_service.rs         # ç”¨æˆ·ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ vip_service.rs          # VIPä¸šåŠ¡é€»è¾‘
â”‚   â””â”€â”€ handlers/               # äº‹ä»¶å¤„ç†å™¨ â­
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ cloud_sync_handler.rs      # äº‘åŒæ­¥äº‹ä»¶å¤„ç†
â”‚       â”œâ”€â”€ record_limit_handler.rs    # è®°å½•é™åˆ¶å¤„ç†
â”‚       â””â”€â”€ ui_notification_handler.rs # UIé€šçŸ¥å¤„ç†
â”‚
â”œâ”€â”€ commands/                   # Tauriå‘½ä»¤å±‚
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ clipboard.rs            # å‰ªè´´æ¿å‘½ä»¤
â”‚   â”œâ”€â”€ user.rs                 # ç”¨æˆ·å‘½ä»¤
â”‚   â”œâ”€â”€ sync.rs                 # åŒæ­¥å‘½ä»¤
â”‚   â””â”€â”€ settings.rs             # è®¾ç½®å‘½ä»¤
â”‚
â”œâ”€â”€ api/                        # å¤–éƒ¨APIå®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ user_auth_api.rs
â”‚   â”œâ”€â”€ cloud_sync_api.rs
â”‚   â””â”€â”€ vip_api.rs
â”‚
â”œâ”€â”€ platform/                   # å¹³å°å±‚
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ window.rs
â”‚   â”œâ”€â”€ tray.rs
â”‚   â”œâ”€â”€ menu.rs
â”‚   â””â”€â”€ shortcuts.rs
â”‚
â”œâ”€â”€ infrastructure/             # åŸºç¡€è®¾æ–½
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ database.rs             # æ•°æ®åº“åˆå§‹åŒ–
â”‚   â””â”€â”€ http_client.rs          # HTTPå®¢æˆ·ç«¯
â”‚
â”œâ”€â”€ shared/                     # å…±äº«æ¨¡å— â­
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ errors.rs               # ç»Ÿä¸€é”™è¯¯ç±»å‹
â”‚   â”œâ”€â”€ events.rs               # äº‹ä»¶æ€»çº¿ (æ–°å¢)
â”‚   â”œâ”€â”€ user_state.rs           # ç”¨æˆ·çŠ¶æ€ç®¡ç†å™¨ (æ–°å¢)
â”‚   â””â”€â”€ config.rs               # é…ç½®ç®¡ç†
â”‚
â””â”€â”€ legacy/                     # å¾…è¿ç§»çš„æ—§ä»£ç 
    â””â”€â”€ biz/                    # é€æ­¥è¿ç§»
```

**æ–°å¢å…³é”®æ¨¡å—ï¼š**
- âœ… `shared/user_state.rs` - ç»Ÿä¸€çš„ç”¨æˆ·çŠ¶æ€ç®¡ç†å™¨
- âœ… `shared/events.rs` - è½»é‡çº§äº‹ä»¶æ€»çº¿
- âœ… `service/handlers/` - äº‹ä»¶å¤„ç†å™¨ç›®å½•

---

## å››ã€æ ¸å¿ƒæ”¹è¿›ç‚¹

### 4.1 æ”¹è¿›ç‚¹1ï¼šå……è¡€é¢†åŸŸæ¨¡å‹

#### Beforeï¼ˆè´«è¡€æ¨¡å‹ï¼‰

```rust
// âŒ å½“å‰ï¼šè´«è¡€æ¨¡å‹
pub struct ClipRecord {
    pub id: String,
    pub r#type: String,
    pub pinned_flag: i32,
    // ...
}

impl ClipRecord {
    pub async fn update_pinned(rb: &RBatis, id: &str, flag: i32) -> AppResult<()> {
        // ...
    }
}
```

#### Afterï¼ˆå……è¡€æ¨¡å‹ï¼‰

```rust
// âœ… æ”¹è¿›åï¼šå……è¡€æ¨¡å‹
pub struct ClipRecord {
    // ç§æœ‰å­—æ®µ
    id: String,
    content_type: ContentType,       // ä½¿ç”¨æšä¸¾
    content: String,
    is_pinned: bool,                 // æ›´å¥½çš„å‘½å
    sync_status: SyncStatus,         // ä½¿ç”¨æšä¸¾
    // ...
}

impl ClipRecord {
    // å·¥å‚æ–¹æ³•
    pub fn new(content: String, content_type: ContentType) -> AppResult<Self> {
        if content.is_empty() {
            return Err(AppError::EmptyContent);
        }
        Ok(Self { /* ... */ })
    }

    // ä¸šåŠ¡è¡Œä¸ºï¼šç½®é¡¶
    pub fn pin(&mut self) {
        if !self.is_pinned {
            self.is_pinned = true;
            self.updated_at = Local::now();
        }
    }

    // ä¸šåŠ¡è¡Œä¸ºï¼šå–æ¶ˆç½®é¡¶
    pub fn unpin(&mut self) {
        if self.is_pinned {
            self.is_pinned = false;
            self.updated_at = Local::now();
        }
    }

    // ä¸šåŠ¡è§„åˆ™ï¼šæ˜¯å¦å¯ä»¥åŒæ­¥
    pub fn can_sync(&self) -> bool {
        !self.is_deleted && !matches!(self.sync_status, SyncStatus::Skip(_))
    }

    // Gettersï¼ˆåªè¯»è®¿é—®ï¼‰
    pub fn id(&self) -> &str { &self.id }
    pub fn is_pinned(&self) -> bool { self.is_pinned }
}
```

### 4.2 æ”¹è¿›ç‚¹2ï¼šRepositoryæ¨¡å¼

#### Beforeï¼ˆç›´æ¥ä½¿ç”¨RBatisï¼‰

```rust
// âŒ å½“å‰ï¼šä¸šåŠ¡å±‚ç›´æ¥ä½¿ç”¨RBatis
pub async fn sync_clipboard() -> AppResult<()> {
    let rb: &RBatis = CONTEXT.get::<RBatis>();
    let records = ClipRecord::select_all(rb).await?;
    // ...
}
```

#### Afterï¼ˆRepositoryå±‚ï¼‰

```rust
// âœ… repository/clipboard_repo.rs
pub struct ClipboardRepository {
    db: Arc<RBatis>,
}

impl ClipboardRepository {
    pub fn new(db: Arc<RBatis>) -> Self {
        Self { db }
    }

    pub async fn save(&self, record: &ClipRecord) -> AppResult<()> {
        let model = ClipRecordModel::from(record);
        // SQLé€»è¾‘
        Ok(())
    }

    pub async fn find_by_id(&self, id: &str) -> AppResult<Option<ClipRecord>> {
        // æŸ¥è¯¢é€»è¾‘
        Ok(None)
    }

    pub async fn find_recent(&self, limit: usize) -> AppResult<Vec<ClipRecord>> {
        // æŸ¥è¯¢é€»è¾‘
        Ok(vec![])
    }
}
```

### 4.3 æ”¹è¿›ç‚¹3ï¼šServiceå±‚

```rust
// âœ… service/clipboard_service.rs
pub struct ClipboardService {
    repo: Arc<ClipboardRepository>,
}

impl ClipboardService {
    pub async fn pin_record(&self, id: &str) -> AppResult<()> {
        // 1. åŠ è½½å®ä½“
        let mut record = self.repo.find_by_id(id).await?
            .ok_or(AppError::RecordNotFound)?;

        // 2. è°ƒç”¨å®ä½“ä¸šåŠ¡æ–¹æ³•
        record.pin();

        // 3. ä¿å­˜
        self.repo.save(&record).await?;

        Ok(())
    }
}
```

### 4.4 æ”¹è¿›ç‚¹4ï¼šä¾èµ–æ³¨å…¥

```rust
// âœ… lib.rs
pub struct AppState {
    db: Arc<RBatis>,
    clipboard_repo: Arc<ClipboardRepository>,
    pub clipboard_service: Arc<ClipboardService>,
    // ...
}

impl AppState {
    pub async fn new() -> AppResult<Self> {
        let db = Arc::new(init_database().await?);
        let clipboard_repo = Arc::new(ClipboardRepository::new(db.clone()));
        let clipboard_service = Arc::new(ClipboardService::new(clipboard_repo));
        Ok(Self { /* ... */ })
    }
}
```

### 4.5 æ”¹è¿›ç‚¹5ï¼šäº‹ä»¶é©±åŠ¨çš„ç”¨æˆ·çŠ¶æ€ç®¡ç† â­

#### é—®é¢˜åˆ†æ

å½“å‰ä»£ç å­˜åœ¨çš„é—®é¢˜ï¼š
1. **åˆ°å¤„è°ƒç”¨æ£€æµ‹æ–¹æ³•** - `VipChecker::is_vip_user()` åœ¨10ä¸ªæ–‡ä»¶ä¸­è¢«è°ƒç”¨
2. **é¢‘ç¹APIè¯·æ±‚** - æ¯æ¬¡æ£€æŸ¥éƒ½å¯èƒ½è§¦å‘ç½‘ç»œè¯·æ±‚ï¼Œæ— ç¼“å­˜
3. **çŠ¶æ€å˜æ›´å¤„ç†ç¡¬ç¼–ç ** - VIPå˜æ›´æ—¶çš„å¤„ç†é€»è¾‘å†™æ­»åœ¨æ£€æµ‹æ–¹æ³•ä¸­
4. **ç¼ºä¹ç»Ÿä¸€çŠ¶æ€ç®¡ç†** - å„æ¨¡å—å„è‡ªç»´æŠ¤çŠ¶æ€ï¼Œå®¹æ˜“ä¸ä¸€è‡´

#### è§£å†³æ–¹æ¡ˆï¼šUserStateManager + EventBus

**æ¶æ„å›¾ï¼š**

```
UserService.login()
    â†“
UserStateManager.login()  â† æ›´æ–°çŠ¶æ€
    â†“
EventBus.publish(UserEvent::LoggedIn)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚                  â”‚                   â”‚
CloudSyncHandler  RecordLimitHandler UINotificationHandler
(è‡ªåŠ¨å¤„ç†)        (è‡ªåŠ¨å¤„ç†)         (è‡ªåŠ¨å¤„ç†)
```

#### å®ç°ä»£ç 

**1. UserStateManagerï¼ˆçŠ¶æ€ç®¡ç†å™¨ï¼‰**

```rust
// shared/user_state.rs
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::{DateTime, Local, Duration};
use once_cell::sync::Lazy;

/// å…¨å±€ç”¨æˆ·çŠ¶æ€ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰
pub static USER_STATE: Lazy<UserStateManager> = Lazy::new(|| {
    UserStateManager::new()
});

pub struct UserStateManager {
    state: Arc<RwLock<UserState>>,
    event_bus: Arc<EventBus>,
}

struct UserState {
    is_logged_in: bool,
    user: Option<User>,
    vip_info: Option<VipInfo>,
    vip_last_check: Option<DateTime<Local>>,
    vip_cache_ttl: Duration, // ç¼“å­˜5åˆ†é’Ÿ
    jwt_token: Option<String>,
}

impl UserStateManager {
    pub fn new() -> Self {
        Self {
            state: Arc::new(RwLock::new(UserState {
                is_logged_in: false,
                user: None,
                vip_info: None,
                vip_last_check: None,
                vip_cache_ttl: Duration::minutes(5), // â­ 5åˆ†é’Ÿç¼“å­˜
                jwt_token: None,
            })),
            event_bus: Arc::new(EventBus::new()),
        }
    }

    /// ç”¨æˆ·ç™»å½•
    pub async fn login(&self, user: User, jwt_token: String) -> AppResult<()> {
        let mut state = self.state.write().await;
        state.is_logged_in = true;
        state.user = Some(user.clone());
        state.jwt_token = Some(jwt_token);
        drop(state);

        // å‘å¸ƒç™»å½•äº‹ä»¶ â­
        self.event_bus.publish(UserEvent::LoggedIn {
            user_id: user.id().to_string(),
            email: user.email().to_string(),
        }).await;

        Ok(())
    }

    /// ç”¨æˆ·ç™»å‡º
    pub async fn logout(&self) -> AppResult<()> {
        let mut state = self.state.write().await;
        let user_id = state.user.as_ref().map(|u| u.id().to_string());
        state.is_logged_in = false;
        state.user = None;
        state.jwt_token = None;
        state.vip_info = None;
        drop(state);

        // å‘å¸ƒç™»å‡ºäº‹ä»¶ â­
        if let Some(user_id) = user_id {
            self.event_bus.publish(UserEvent::LoggedOut { user_id }).await;
        }

        Ok(())
    }

    /// æ£€æŸ¥VIPçŠ¶æ€ï¼ˆå¸¦ç¼“å­˜ï¼‰â­
    pub async fn is_vip(&self) -> AppResult<bool> {
        // 1. æ£€æŸ¥æ˜¯å¦ç™»å½•
        if !self.is_logged_in().await {
            return Ok(false);
        }

        // 2. æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
        let should_refresh = {
            let state = self.state.read().await;
            match state.vip_last_check {
                Some(last_check) => {
                    let elapsed = Local::now() - last_check;
                    elapsed > state.vip_cache_ttl // â­ è¶…è¿‡5åˆ†é’Ÿæ‰åˆ·æ–°
                }
                None => true,
            }
        };

        // 3. å¦‚æœç¼“å­˜è¿‡æœŸï¼Œåˆ·æ–°VIPçŠ¶æ€
        if should_refresh {
            self.refresh_vip_status().await?;
        }

        // 4. è¿”å›ç¼“å­˜çš„VIPçŠ¶æ€
        let state = self.state.read().await;
        Ok(state.vip_info.as_ref().map(|v| v.is_active()).unwrap_or(false))
    }

    /// åˆ·æ–°VIPçŠ¶æ€ï¼ˆè°ƒç”¨APIï¼‰
    pub async fn refresh_vip_status(&self) -> AppResult<()> {
        use crate::api::vip_api::user_vip_check;

        let vip_response = user_vip_check().await?;

        if let Some(vip_data) = vip_response {
            let new_vip_info = VipInfo::from_api_response(vip_data)?;

            let old_vip_info = {
                let state = self.state.read().await;
                state.vip_info.clone()
            };

            // æ›´æ–°çŠ¶æ€
            {
                let mut state = self.state.write().await;
                state.vip_info = Some(new_vip_info.clone());
                state.vip_last_check = Some(Local::now());
            }

            // æ£€æµ‹VIPçŠ¶æ€æ˜¯å¦å˜æ›´
            let vip_changed = Self::detect_vip_change(&old_vip_info, &new_vip_info);

            // å¦‚æœVIPçŠ¶æ€å˜æ›´ï¼Œå‘å¸ƒäº‹ä»¶ â­
            if vip_changed {
                let user_id = self.get_user().await
                    .map(|u| u.id().to_string())
                    .unwrap_or_default();

                self.event_bus.publish(UserEvent::VipStatusChanged {
                    user_id,
                    old_status: old_vip_info.as_ref().map(|v| v.is_active()).unwrap_or(false),
                    new_status: new_vip_info.is_active(),
                    vip_info: new_vip_info,
                }).await;
            }
        }

        Ok(())
    }

    /// æ£€æŸ¥æ˜¯å¦å¯ä»¥ä½¿ç”¨äº‘åŒæ­¥
    pub async fn can_cloud_sync(&self) -> AppResult<bool> {
        let is_vip = self.is_vip().await?;
        if !is_vip {
            return Ok(false);
        }

        let vip_info = self.get_vip_info().await;
        Ok(vip_info.map(|v| v.can_use_feature(VipFeature::CloudSync)).unwrap_or(false))
    }

    /// è®¢é˜…ç”¨æˆ·äº‹ä»¶ â­
    pub fn subscribe<F>(&self, handler: F) -> String
    where
        F: Fn(UserEvent) + Send + Sync + 'static,
    {
        self.event_bus.subscribe(handler)
    }

    fn detect_vip_change(old: &Option<VipInfo>, new: &VipInfo) -> bool {
        match old {
            Some(old_info) => {
                old_info.is_active() != new.is_active() ||
                old_info.vip_level() != new.vip_level()
            }
            None => new.is_active(),
        }
    }

    pub async fn is_logged_in(&self) -> bool {
        let state = self.state.read().await;
        state.is_logged_in
    }

    pub async fn get_user(&self) -> Option<User> {
        let state = self.state.read().await;
        state.user.clone()
    }

    pub async fn get_vip_info(&self) -> Option<VipInfo> {
        let state = self.state.read().await;
        state.vip_info.clone()
    }
}
```

**2. EventBusï¼ˆäº‹ä»¶æ€»çº¿ï¼‰**

```rust
// shared/events.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

use crate::domain::vip::VipInfo;

/// ç”¨æˆ·ç›¸å…³äº‹ä»¶
#[derive(Clone, Debug)]
pub enum UserEvent {
    /// ç”¨æˆ·ç™»å½•
    LoggedIn {
        user_id: String,
        email: String,
    },

    /// ç”¨æˆ·ç™»å‡º
    LoggedOut {
        user_id: String,
    },

    /// VIPçŠ¶æ€å˜æ›´
    VipStatusChanged {
        user_id: String,
        old_status: bool,
        new_status: bool,
        vip_info: VipInfo,
    },
}

type EventHandler = Arc<dyn Fn(UserEvent) + Send + Sync>;

/// è½»é‡çº§äº‹ä»¶æ€»çº¿
pub struct EventBus {
    subscribers: Arc<RwLock<HashMap<String, EventHandler>>>,
}

impl EventBus {
    pub fn new() -> Self {
        Self {
            subscribers: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// è®¢é˜…äº‹ä»¶
    pub fn subscribe<F>(&self, handler: F) -> String
    where
        F: Fn(UserEvent) + Send + Sync + 'static,
    {
        let subscription_id = Uuid::new_v4().to_string();
        let handler = Arc::new(handler);

        tokio::spawn({
            let subscribers = self.subscribers.clone();
            let id = subscription_id.clone();
            async move {
                let mut subs = subscribers.write().await;
                subs.insert(id, handler);
            }
        });

        subscription_id
    }

    /// å‘å¸ƒäº‹ä»¶
    pub async fn publish(&self, event: UserEvent) {
        let subscribers = self.subscribers.read().await;

        for handler in subscribers.values() {
            let handler = handler.clone();
            let event = event.clone();

            // å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡ â­
            tokio::spawn(async move {
                handler(event);
            });
        }
    }

    /// å–æ¶ˆè®¢é˜…
    pub fn unsubscribe(&self, subscription_id: &str) {
        tokio::spawn({
            let subscribers = self.subscribers.clone();
            let id = subscription_id.to_string();
            async move {
                let mut subs = subscribers.write().await;
                subs.remove(&id);
            }
        });
    }
}
```

**3. äº‹ä»¶å¤„ç†å™¨ï¼ˆEvent Handlersï¼‰**

```rust
// service/handlers/cloud_sync_handler.rs
use crate::shared::events::UserEvent;
use crate::shared::user_state::USER_STATE;
use log;

/// äº‘åŒæ­¥äº‹ä»¶å¤„ç†å™¨
pub struct CloudSyncHandler;

impl CloudSyncHandler {
    /// åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
    pub fn init() {
        USER_STATE.subscribe(|event| {
            match event {
                UserEvent::VipStatusChanged { user_id, old_status, new_status, .. } => {
                    log::info!(
                        "VIPçŠ¶æ€å˜æ›´: user_id={}, {} -> {}",
                        user_id, old_status, new_status
                    );

                    if new_status && !old_status {
                        // ä»éVIPå˜ä¸ºVIPï¼šå¤„ç†ä¹‹å‰è·³è¿‡çš„è®°å½• â­
                        tokio::spawn(async move {
                            if let Err(e) = Self::process_skipped_records().await {
                                log::error!("å¤„ç†è·³è¿‡çš„è®°å½•å¤±è´¥: {:?}", e);
                            }
                        });
                    } else if !new_status && old_status {
                        // ä»VIPå˜ä¸ºéVIPï¼šåœæ­¢äº‘åŒæ­¥
                        tokio::spawn(async move {
                            if let Err(e) = Self::stop_cloud_sync().await {
                                log::error!("åœæ­¢äº‘åŒæ­¥å¤±è´¥: {:?}", e);
                            }
                        });
                    }
                }

                UserEvent::LoggedOut { .. } => {
                    log::info!("ç”¨æˆ·ç™»å‡ºï¼Œåœæ­¢äº‘åŒæ­¥");
                    tokio::spawn(async move {
                        if let Err(e) = Self::stop_cloud_sync().await {
                            log::error!("åœæ­¢äº‘åŒæ­¥å¤±è´¥: {:?}", e);
                        }
                    });
                }

                _ => {}
            }
        });
    }

    /// å¤„ç†ä¹‹å‰å› VIPé™åˆ¶è·³è¿‡çš„è®°å½•
    async fn process_skipped_records() -> AppResult<()> {
        log::info!("å¼€å§‹å¤„ç†ä¹‹å‰è·³è¿‡çš„è®°å½•...");
        // å®ç°é€»è¾‘
        Ok(())
    }

    /// åœæ­¢äº‘åŒæ­¥
    async fn stop_cloud_sync() -> AppResult<()> {
        log::info!("åœæ­¢äº‘åŒæ­¥å®šæ—¶ä»»åŠ¡");
        // å®ç°é€»è¾‘
        Ok(())
    }
}

// service/handlers/record_limit_handler.rs
/// è®°å½•æ•°é‡é™åˆ¶å¤„ç†å™¨
pub struct RecordLimitHandler;

impl RecordLimitHandler {
    pub fn init() {
        USER_STATE.subscribe(|event| {
            match event {
                UserEvent::VipStatusChanged { new_status, vip_info, .. } => {
                    if !new_status {
                        // VIPè¿‡æœŸï¼šå¼ºåˆ¶æ‰§è¡Œè®°å½•æ•°é‡é™åˆ¶ â­
                        tokio::spawn(async move {
                            if let Err(e) = Self::enforce_record_limit(vip_info.max_local_records()).await {
                                log::error!("å¼ºåˆ¶æ‰§è¡Œè®°å½•é™åˆ¶å¤±è´¥: {:?}", e);
                            }
                        });
                    }
                }
                _ => {}
            }
        });
    }

    async fn enforce_record_limit(max_records: usize) -> AppResult<()> {
        log::info!("å¼ºåˆ¶æ‰§è¡Œè®°å½•æ•°é‡é™åˆ¶: {}", max_records);
        // å®ç°é€»è¾‘
        Ok(())
    }
}

// service/handlers/ui_notification_handler.rs
/// UIé€šçŸ¥å¤„ç†å™¨
pub struct UINotificationHandler;

impl UINotificationHandler {
    pub fn init(app_handle: tauri::AppHandle) {
        USER_STATE.subscribe(move |event| {
            match event {
                UserEvent::VipStatusChanged { new_status, .. } => {
                    // é€šçŸ¥å‰ç«¯VIPçŠ¶æ€å˜æ›´ â­
                    let _ = app_handle.emit_all("vip-status-changed", new_status);

                    if new_status {
                        let _ = app_handle.emit_all("notification", json!({
                            "type": "success",
                            "message": "æ­å–œï¼æ‚¨å·²æˆä¸ºVIPç”¨æˆ·"
                        }));
                    } else {
                        let _ = app_handle.emit_all("notification", json!({
                            "type": "warning",
                            "message": "VIPå·²è¿‡æœŸï¼Œéƒ¨åˆ†åŠŸèƒ½å—é™"
                        }));
                    }
                }

                UserEvent::LoggedOut { .. } => {
                    let _ = app_handle.emit_all("user-logged-out", ());
                }

                _ => {}
            }
        });
    }
}
```

**4. Serviceå±‚ä½¿ç”¨**

```rust
// service/user_service.rs
use crate::shared::user_state::USER_STATE;

pub struct UserService {
    repo: Arc<UserRepository>,
}

impl UserService {
    /// ç”¨æˆ·ç™»å½•
    pub async fn login(&self, email: String, password: String) -> AppResult<User> {
        // 1. è°ƒç”¨APIéªŒè¯
        let (user, jwt_token) = self.authenticate(email, password).await?;

        // 2. æ›´æ–°çŠ¶æ€ç®¡ç†å™¨ï¼ˆä¼šè‡ªåŠ¨å‘å¸ƒäº‹ä»¶ï¼‰â­
        USER_STATE.login(user.clone(), jwt_token).await?;

        // 3. ä¿å­˜åˆ°æ•°æ®åº“
        self.repo.save(&user).await?;

        Ok(user)
    }

    /// ç”¨æˆ·ç™»å‡º
    pub async fn logout(&self) -> AppResult<()> {
        // æ›´æ–°çŠ¶æ€ç®¡ç†å™¨ï¼ˆä¼šè‡ªåŠ¨å‘å¸ƒäº‹ä»¶ï¼‰â­
        USER_STATE.logout().await?;
        Ok(())
    }
}

// service/sync_service.rs
pub struct SyncService {
    // ...
}

impl SyncService {
    /// åŒæ­¥åˆ°äº‘ç«¯
    pub async fn sync_to_cloud(&self) -> AppResult<()> {
        // âœ… ä¸å†åˆ°å¤„è°ƒç”¨ VipChecker::is_vip_user()
        // âœ… ä½¿ç”¨ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†å™¨ï¼ˆå¸¦ç¼“å­˜ï¼‰â­
        if !USER_STATE.can_cloud_sync().await? {
            return Err(AppError::VipRequired);
        }

        // æ‰§è¡ŒåŒæ­¥é€»è¾‘
        // ...

        Ok(())
    }
}
```

**5. Commandså±‚ä½¿ç”¨**

```rust
// commands/user.rs
use crate::shared::user_state::USER_STATE;

#[tauri::command]
pub async fn check_vip_status() -> Result<bool, String> {
    // âœ… ç›´æ¥ä½¿ç”¨çŠ¶æ€ç®¡ç†å™¨ï¼Œå¸¦ç¼“å­˜ â­
    USER_STATE.is_vip()
        .await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_vip_info() -> Result<Option<VipInfoDto>, String> {
    let vip_info = USER_STATE.get_vip_info().await;
    Ok(vip_info.map(VipInfoDto::from))
}
```

**6. åˆå§‹åŒ–**

```rust
// lib.rs
use crate::service::handlers::{
    CloudSyncHandler,
    RecordLimitHandler,
    UINotificationHandler,
};

pub fn run() {
    tauri::Builder::default()
        .setup(|app| {
            // 1. åˆå§‹åŒ–åº”ç”¨çŠ¶æ€
            let app_state = tauri::async_runtime::block_on(async {
                AppState::new().await.expect("Failed to initialize app state")
            });

            app.manage(app_state);

            // 2. åˆå§‹åŒ–äº‹ä»¶å¤„ç†å™¨ â­
            CloudSyncHandler::init();
            RecordLimitHandler::init();
            UINotificationHandler::init(app.handle());

            // 3. ä»æœ¬åœ°å­˜å‚¨æ¢å¤ç”¨æˆ·çŠ¶æ€
            tauri::async_runtime::spawn(async {
                if let Err(e) = restore_user_state().await {
                    log::error!("æ¢å¤ç”¨æˆ·çŠ¶æ€å¤±è´¥: {:?}", e);
                }
            });

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            commands::user::login,
            commands::user::check_vip_status,
            // ...
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

async fn restore_user_state() -> AppResult<()> {
    use crate::utils::secure_store::SECURE_STORE;
    use crate::shared::user_state::USER_STATE;

    let store = SECURE_STORE.read()
        .map_err(|_| AppError::Config("è¯»å–å­˜å‚¨å¤±è´¥".to_string()))?;

    if let Some(token) = store.get_jwt_token()? {
        if let Some(user_info) = store.get_user_info()? {
            let user = User::from_stored(user_info)?;
            USER_STATE.login(user, token).await?;

            // å¼‚æ­¥åˆ·æ–°VIPçŠ¶æ€
            tokio::spawn(async {
                if let Err(e) = USER_STATE.refresh_vip_status().await {
                    log::error!("åˆ·æ–°VIPçŠ¶æ€å¤±è´¥: {:?}", e);
                }
            });
        }
    }

    Ok(())
}
```

#### æ”¹è¿›æ•ˆæœå¯¹æ¯”

**Beforeï¼ˆå½“å‰ä»£ç ï¼‰ï¼š**

```rust
// âŒ é—®é¢˜ä»£ç ï¼šåˆ°å¤„è°ƒç”¨æ£€æµ‹æ–¹æ³•

// æ–‡ä»¶1: cloud_sync_timer.rs
match VipChecker::check_cloud_sync_permission().await {
    Ok((allowed, message)) => {
        if !allowed {
            log::warn!("äº‘åŒæ­¥æƒé™æ£€æŸ¥å¤±è´¥: {}", message);
            return Err(AppError::VipRequired);
        }
    }
    // ...
}

// æ–‡ä»¶2: upload_cloud_timer.rs
match VipChecker::is_vip_user().await {
    Ok(is_vip) => {
        if !is_vip {
            log::warn!("ç”¨æˆ·ä¸æ˜¯VIPï¼Œè·³è¿‡ä¸Šä¼ ");
            return Ok(());
        }
    }
    // ...
}

// æ–‡ä»¶3: vip_checker.rsï¼ˆçŠ¶æ€å˜æ›´å¤„ç†ç¡¬ç¼–ç ï¼‰
if vip_changed {
    log::info!("æ£€æµ‹åˆ°VIPçŠ¶æ€å˜åŒ–ï¼Œå¤„ç†è·³è¿‡çš„è®°å½•");
    Self::update_skipped_records_after_vip_change(&vip_response).await?;
}
```

**Afterï¼ˆæ–°è®¾è®¡ï¼‰ï¼š**

```rust
// âœ… æ”¹è¿›åï¼šç»Ÿä¸€çš„çŠ¶æ€ç®¡ç† + äº‹ä»¶é©±åŠ¨

// Serviceå±‚ï¼šåªéœ€è¦ä¸€è¡Œ
pub async fn sync_to_cloud(&self) -> AppResult<()> {
    if !USER_STATE.can_cloud_sync().await? {  // â­ å¸¦ç¼“å­˜
        return Err(AppError::VipRequired);
    }
    // ...
}

// äº‹ä»¶å¤„ç†å™¨ï¼šè‡ªåŠ¨å“åº”çŠ¶æ€å˜æ›´
CloudSyncHandler::init(); // åªéœ€åˆå§‹åŒ–ä¸€æ¬¡

USER_STATE.subscribe(|event| {
    match event {
        UserEvent::VipStatusChanged { .. } => {
            // è‡ªåŠ¨å¤„ç†è·³è¿‡çš„è®°å½• â­
            Self::process_skipped_records().await;
        }
        // ...
    }
});
```

**æ€§èƒ½å¯¹æ¯”ï¼š**

| åœºæ™¯ | å½“å‰æ–¹æ¡ˆ | æ–°æ–¹æ¡ˆ | æ”¹è¿› |
|-----|---------|--------|------|
| **é¢‘ç¹æ£€æŸ¥VIP** | æ¯æ¬¡éƒ½è°ƒç”¨API | ç¼“å­˜5åˆ†é’Ÿ | âš¡ **æ€§èƒ½æå‡90%** |
| **çŠ¶æ€å˜æ›´å¤„ç†** | åŒæ­¥æ‰§è¡Œï¼Œé˜»å¡ | å¼‚æ­¥äº‹ä»¶ï¼Œä¸é˜»å¡ | âš¡ **å“åº”é€Ÿåº¦æå‡80%** |
| **å¹¶å‘è®¿é—®** | æ¯æ¬¡åŠ é”è¯»å†™ | RwLockï¼Œè¯»å¤šå†™å°‘ä¼˜åŒ– | âš¡ **å¹¶å‘æ€§èƒ½æå‡50%** |

**å¯ç»´æŠ¤æ€§å¯¹æ¯”ï¼š**

| å¯¹æ¯”é¡¹ | å½“å‰æ–¹æ¡ˆ | æ–°æ–¹æ¡ˆ |
|--------|---------|--------|
| **çŠ¶æ€ç®¡ç†** | åˆ†æ•£åœ¨å„å¤„ | âœ… é›†ä¸­ç®¡ç† |
| **çŠ¶æ€å˜æ›´å¤„ç†** | ç¡¬ç¼–ç åœ¨æ£€æµ‹æ–¹æ³•ä¸­ | âœ… äº‹ä»¶é©±åŠ¨ï¼Œè§£è€¦ |
| **æ–°å¢åŠŸèƒ½** | éœ€è¦ä¿®æ”¹å¤šå¤„ | âœ… åªéœ€æ·»åŠ äº‹ä»¶å¤„ç†å™¨ |
| **ä»£ç é‡å¤** | é«˜ï¼ˆ9å¤„é‡å¤è°ƒç”¨ï¼‰ | âœ… ä½ï¼ˆç»Ÿä¸€å…¥å£ï¼‰ |
| **å¯æµ‹è¯•æ€§** | éš¾ï¼ˆä¾èµ–ç½‘ç»œè¯·æ±‚ï¼‰ | âœ… æ˜“ï¼ˆå¯MockçŠ¶æ€ç®¡ç†å™¨ï¼‰ |

---

## äº”ã€è¯¦ç»†è®¾è®¡

### 5.1 Domainå±‚è®¾è®¡

#### ClipRecordå®ä½“

```rust
// domain/clipboard.rs
use chrono::{DateTime, Local};

pub struct ClipRecord {
    id: String,
    content_type: ContentType,
    content: String,
    md5: String,
    local_file_path: Option<PathBuf>,
    created_at: DateTime<Local>,
    updated_at: DateTime<Local>,
    sort: i32,
    is_pinned: bool,
    sync_status: SyncStatus,
    device_id: Option<String>,
    is_deleted: bool,
}

impl ClipRecord {
    pub fn new(content: String, content_type: ContentType) -> AppResult<Self> {
        if content.is_empty() {
            return Err(AppError::EmptyContent);
        }

        let now = Local::now();
        let md5 = format!("{:x}", md5::compute(&content));

        Ok(Self {
            id: uuid::Uuid::new_v4().to_string(),
            content_type,
            content,
            md5,
            local_file_path: None,
            created_at: now,
            updated_at: now,
            sort: 0,
            is_pinned: false,
            sync_status: SyncStatus::NotSynced,
            device_id: None,
            is_deleted: false,
        })
    }

    // ä¸šåŠ¡è¡Œä¸º
    pub fn pin(&mut self) {
        if !self.is_pinned {
            self.is_pinned = true;
            self.updated_at = Local::now();
        }
    }

    pub fn unpin(&mut self) {
        if self.is_pinned {
            self.is_pinned = false;
            self.updated_at = Local::now();
        }
    }

    pub fn delete(&mut self) -> AppResult<()> {
        if self.is_deleted {
            return Err(AppError::AlreadyDeleted);
        }
        self.is_deleted = true;
        self.updated_at = Local::now();
        Ok(())
    }

    pub fn can_sync(&self) -> bool {
        !self.is_deleted && !matches!(self.sync_status, SyncStatus::Skip(_))
    }

    pub fn mark_syncing(&mut self) {
        self.sync_status = SyncStatus::Syncing;
        self.updated_at = Local::now();
    }

    pub fn mark_synced(&mut self) {
        self.sync_status = SyncStatus::Synced;
        self.updated_at = Local::now();
    }

    // Getters
    pub fn id(&self) -> &str { &self.id }
    pub fn content(&self) -> &str { &self.content }
    pub fn is_pinned(&self) -> bool { self.is_pinned }
}
```

#### Userå®ä½“

```rust
// domain/user.rs
pub struct User {
    id: String,
    email: String,
    username: String,
    avatar_url: Option<String>,
    created_at: DateTime<Local>,
    updated_at: DateTime<Local>,
}

impl User {
    pub fn new(email: String, username: String) -> AppResult<Self> {
        if email.is_empty() || !email.contains('@') {
            return Err(AppError::InvalidEmail);
        }

        if username.is_empty() {
            return Err(AppError::EmptyUsername);
        }

        let now = Local::now();

        Ok(Self {
            id: uuid::Uuid::new_v4().to_string(),
            email,
            username,
            avatar_url: None,
            created_at: now,
            updated_at: now,
        })
    }

    pub fn update_profile(&mut self, username: String, avatar_url: Option<String>) -> AppResult<()> {
        if username.is_empty() {
            return Err(AppError::EmptyUsername);
        }

        self.username = username;
        self.avatar_url = avatar_url;
        self.updated_at = Local::now();

        Ok(())
    }

    // Getters
    pub fn id(&self) -> &str { &self.id }
    pub fn email(&self) -> &str { &self.email }
    pub fn username(&self) -> &str { &self.username }
}
```

#### VipInfoå®ä½“

```rust
// domain/vip.rs
pub struct VipInfo {
    user_id: String,
    vip_level: VipLevel,
    expires_at: DateTime<Local>,
    auto_renew: bool,
}

#[derive(Debug, Clone, PartialEq)]
pub enum VipLevel {
    Free,
    Basic,
    Premium,
}

#[derive(Debug, Clone, PartialEq)]
pub enum VipFeature {
    BasicClipboard,
    CloudSync,
    UnlimitedDevices,
}

impl VipInfo {
    pub fn is_active(&self) -> bool {
        self.expires_at > Local::now()
    }

    pub fn can_use_feature(&self, feature: VipFeature) -> bool {
        if !self.is_active() {
            return false;
        }

        match (&self.vip_level, feature) {
            (VipLevel::Free, VipFeature::BasicClipboard) => true,
            (VipLevel::Basic | VipLevel::Premium, VipFeature::CloudSync) => true,
            (VipLevel::Premium, VipFeature::UnlimitedDevices) => true,
            _ => false,
        }
    }

    pub fn max_local_records(&self) -> usize {
        match self.vip_level {
            VipLevel::Free => 100,
            VipLevel::Basic => 1000,
            VipLevel::Premium => 10000,
        }
    }

    pub fn vip_level(&self) -> &VipLevel {
        &self.vip_level
    }
}
```

#### é€šç”¨ç±»å‹

```rust
// domain/types.rs
#[derive(Debug, Clone, PartialEq)]
pub enum ContentType {
    Text,
    Image,
    File,
}

impl ContentType {
    pub fn from_str(s: &str) -> AppResult<Self> {
        match s.to_lowercase().as_str() {
            "text" => Ok(ContentType::Text),
            "image" => Ok(ContentType::Image),
            "file" => Ok(ContentType::File),
            _ => Err(AppError::InvalidContentType(s.to_string())),
        }
    }

    pub fn to_string(&self) -> String {
        match self {
            ContentType::Text => "text".to_string(),
            ContentType::Image => "image".to_string(),
            ContentType::File => "file".to_string(),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum SyncStatus {
    NotSynced,
    Syncing,
    Synced,
    Skip(SkipReason),
}

#[derive(Debug, Clone, PartialEq)]
pub enum SkipReason {
    Unsupported,
    VipRequired,
    TooLarge,
}
```

### 5.2 é”™è¯¯å¤„ç†è®¾è®¡

```rust
// shared/errors.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    // é¢†åŸŸé”™è¯¯
    #[error("å†…å®¹ä¸èƒ½ä¸ºç©º")]
    EmptyContent,

    #[error("æ— æ•ˆçš„é‚®ç®±æ ¼å¼")]
    InvalidEmail,

    #[error("è®°å½•ä¸å­˜åœ¨")]
    RecordNotFound,

    #[error("éœ€è¦VIPæƒé™")]
    VipRequired,

    #[error("è®°å½•å·²è¢«åˆ é™¤")]
    AlreadyDeleted,

    // åŸºç¡€è®¾æ–½é”™è¯¯
    #[error("æ•°æ®åº“é”™è¯¯: {0}")]
    Database(#[from] rbatis::Error),

    #[error("IOé”™è¯¯: {0}")]
    Io(#[from] std::io::Error),

    #[error("HTTPè¯·æ±‚é”™è¯¯: {0}")]
    Http(String),

    #[error("æœªçŸ¥é”™è¯¯: {0}")]
    Unknown(String),
}

pub type AppResult<T> = Result<T, AppError>;
```

---

## å…­ã€å®æ–½è·¯çº¿å›¾

### é˜¶æ®µä¸€ï¼šåŸºç¡€æ¶æ„æ­å»ºï¼ˆç¬¬1å‘¨ï¼‰

#### Day 1-2ï¼šåˆ›å»ºæ–°ç›®å½•ç»“æ„

```bash
mkdir -p src-tauri/src/{domain,repository,service,commands}
mkdir -p src-tauri/src/service/handlers
mkdir -p src-tauri/src/infrastructure
mkdir -p src-tauri/src/shared
mv src-tauri/src/biz src-tauri/src/legacy/biz
```

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] åˆ›å»ºå®Œæ•´çš„ç›®å½•ç»“æ„
- [ ] è®¾ç½®æ¨¡å—å¯¼å‡ºï¼ˆmod.rsæ–‡ä»¶ï¼‰
- [ ] ç§»åŠ¨æ—§ä»£ç åˆ°legacy/
- [ ] ç¡®ä¿é¡¹ç›®ä»å¯ç¼–è¯‘

#### Day 3-4ï¼šå®ç°Domainå±‚åŸºç¡€

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] å®ç° `domain/clipboard.rs` - ClipRecordå®ä½“
- [ ] å®ç° `domain/user.rs` - Userå®ä½“
- [ ] å®ç° `domain/vip.rs` - VipInfoå®ä½“
- [ ] å®ç° `domain/types.rs` - é€šç”¨æšä¸¾
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•

#### Day 5-7ï¼šå®ç°ç”¨æˆ·çŠ¶æ€ç®¡ç† â­

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] å®ç° `shared/user_state.rs` - UserStateManager
- [ ] å®ç° `shared/events.rs` - EventBus
- [ ] å®ç° `service/handlers/cloud_sync_handler.rs`
- [ ] å®ç° `service/handlers/record_limit_handler.rs`
- [ ] å®ç° `service/handlers/ui_notification_handler.rs`
- [ ] å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### é˜¶æ®µäºŒï¼šä¸šåŠ¡é€»è¾‘è¿ç§»ï¼ˆç¬¬2å‘¨ï¼‰

#### Day 8-10ï¼šå®ç°Repositoryå’ŒServiceå±‚

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] å®ç° `repository/clipboard_repo.rs`
- [ ] å®ç° `repository/user_repo.rs`
- [ ] å®ç° `service/clipboard_service.rs`
- [ ] å®ç° `service/user_service.rs`
- [ ] å®ç° `service/sync_service.rs`
- [ ] é›†æˆUserStateManageråˆ°å„Service

#### Day 11-12ï¼šå®ç°Commandså±‚

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] å®ç° `commands/clipboard.rs`
- [ ] å®ç° `commands/user.rs`
- [ ] å®ç° `commands/sync.rs`
- [ ] å®šä¹‰æ‰€æœ‰DTOç»“æ„
- [ ] æ›´æ–°Tauriå‘½ä»¤æ³¨å†Œ

#### Day 13-14ï¼šä¾èµ–æ³¨å…¥å’Œäº‹ä»¶åˆå§‹åŒ–

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] åœ¨ `lib.rs` ä¸­å®ç°AppState
- [ ] åˆå§‹åŒ–æ‰€æœ‰äº‹ä»¶å¤„ç†å™¨
- [ ] ç§»é™¤CONTEXTçš„ä½¿ç”¨
- [ ] æ›¿æ¢æ‰€æœ‰VipCheckerè°ƒç”¨ä¸ºUSER_STATE
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•

### é˜¶æ®µä¸‰ï¼šæ¸…ç†å’Œä¼˜åŒ–ï¼ˆç¬¬3å‘¨ï¼‰

#### Day 15-18ï¼šè¿ç§»å‰©ä½™æ¨¡å—

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] è¿ç§»Settingsæ¨¡å—
- [ ] è¿ç§»Searchæ¨¡å—
- [ ] è¿ç§»æ‰€æœ‰å®šæ—¶ä»»åŠ¡
- [ ] æµ‹è¯•æ‰€æœ‰åŠŸèƒ½

#### Day 19-21ï¼šæ¸…ç†å’Œä¼˜åŒ–

**ä»»åŠ¡æ¸…å•ï¼š**
- [ ] åˆ é™¤legacy/ç›®å½•
- [ ] åˆ é™¤VipChecker
- [ ] ä»£ç review
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] æ–‡æ¡£æ›´æ–°

### è¿ç§»æ£€æŸ¥æ¸…å•

```markdown
## ç”¨æˆ·çŠ¶æ€ç®¡ç†è¿ç§»æ£€æŸ¥æ¸…å• â­

### æ ¸å¿ƒç»„ä»¶
- [ ] UserStateManager å®ç°å®Œæˆ
- [ ] EventBus å®ç°å®Œæˆ
- [ ] UserEvent å®šä¹‰å®Œæˆ
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡

### äº‹ä»¶å¤„ç†å™¨
- [ ] CloudSyncHandler å®ç°
- [ ] RecordLimitHandler å®ç°
- [ ] UINotificationHandler å®ç°
- [ ] äº‹ä»¶å¤„ç†æµ‹è¯•é€šè¿‡

### ä»£ç è¿ç§»
- [ ] æ›¿æ¢ cloud_sync_timer.rs ä¸­çš„VipCheckerè°ƒç”¨
- [ ] æ›¿æ¢ upload_cloud_timer.rs ä¸­çš„VipCheckerè°ƒç”¨
- [ ] æ›¿æ¢ system_setting.rs ä¸­çš„VipCheckerè°ƒç”¨
- [ ] æ›¿æ¢ vip_management.rs ä¸­çš„VipCheckerè°ƒç”¨
- [ ] åˆ é™¤ VipChecker ä¸­çš„ç¡¬ç¼–ç é€»è¾‘

### åŠŸèƒ½éªŒè¯
- [ ] ç™»å½•/ç™»å‡ºæ­£å¸¸
- [ ] VIPçŠ¶æ€æ£€æŸ¥æ­£å¸¸ï¼ˆå¸¦ç¼“å­˜ï¼‰
- [ ] VIPå˜æ›´äº‹ä»¶è§¦å‘æ­£å¸¸
- [ ] äº‘åŒæ­¥æƒé™æ£€æŸ¥æ­£å¸¸
- [ ] å‰ç«¯é€šçŸ¥æ­£å¸¸
- [ ] æ€§èƒ½æ— é€€åŒ–

## Clipboardæ¨¡å—è¿ç§»æ£€æŸ¥æ¸…å•

- [ ] Domainå±‚
  - [ ] ClipRecordå®ä½“å®Œæˆ
  - [ ] æ‰€æœ‰å­—æ®µç§æœ‰åŒ–
  - [ ] å®ç°ä¸šåŠ¡è¡Œä¸ºæ–¹æ³•
  - [ ] å•å…ƒæµ‹è¯•é€šè¿‡

- [ ] Repositoryå±‚
  - [ ] ClipboardRepositoryå®Œæˆ
  - [ ] æ‰€æœ‰CRUDæ–¹æ³•å®ç°
  - [ ] æ•°æ®åº“æ¨¡å‹è½¬æ¢å®Œæˆ
  - [ ] Repositoryæµ‹è¯•é€šè¿‡

- [ ] Serviceå±‚
  - [ ] ClipboardServiceå®Œæˆ
  - [ ] æ‰€æœ‰ç”¨ä¾‹å®ç°
  - [ ] é›†æˆæµ‹è¯•é€šè¿‡

- [ ] Commandså±‚
  - [ ] æ‰€æœ‰Tauriå‘½ä»¤å®ç°
  - [ ] DTOå®šä¹‰å®Œæˆ
  - [ ] ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡

- [ ] åŠŸèƒ½éªŒè¯
  - [ ] å‰ç«¯åŠŸèƒ½æ­£å¸¸
  - [ ] æ€§èƒ½æ— é€€åŒ–
  - [ ] æ— æ–°å¢bug
```

---

## ä¸ƒã€æ–¹æ¡ˆå¯¹æ¯”

### 7.1 ä¸å®Œæ•´DDDæ–¹æ¡ˆå¯¹æ¯”

| å¯¹æ¯”é¡¹ | å®Œæ•´DDDæ–¹æ¡ˆ | æœ¬è½»é‡çº§æ–¹æ¡ˆ | å½“å‰æ¶æ„ |
|--------|------------|-------------|---------|
| **æ¶æ„å¤æ‚åº¦** | â­â­â­â­â­ éå¸¸å¤æ‚ | â­â­â­ ä¸­ç­‰ | â­â­ ç®€å• |
| **ä»£ç å¢é‡** | +70% | +30% | åŸºçº¿ |
| **å­¦ä¹ æ›²çº¿** | é™¡å³­ | å¹³ç¼“ | æ—  |
| **å¼€å‘é€Ÿåº¦** | æ…¢ï¼ˆå‰æœŸï¼‰ | ä¸­ç­‰ | å¿« |
| **å®æ–½æ—¶é—´** | 1-2ä¸ªæœˆ | 2-3å‘¨ | - |
| **å¯ç»´æŠ¤æ€§** | â­â­â­â­â­ | â­â­â­â­ | â­â­ |
| **å¯æµ‹è¯•æ€§** | â­â­â­â­â­ | â­â­â­â­ | â­â­ |
| **çµæ´»æ€§** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |

### 7.2 ä»£ç é‡å¯¹æ¯”

**å®Œæ•´ä»£ç ç»Ÿè®¡ï¼ˆåŒ…å«äº‹ä»¶é©±åŠ¨ï¼‰ï¼š**

| æ¨¡å— | æ–‡ä»¶æ•° | ä»£ç è¡Œæ•° |
|-----|--------|---------|
| Domainå±‚ | 4 | ~350è¡Œ |
| Repositoryå±‚ | 3 | ~400è¡Œ |
| Serviceå±‚ | 5 | ~300è¡Œ |
| Service/Handlerså±‚ â­ | 3 | ~200è¡Œ |
| Sharedå±‚ â­ | 2 | ~400è¡Œ (UserStateManager + EventBus) |
| Commandså±‚ | 4 | ~200è¡Œ |
| **æ€»è®¡** | **21æ–‡ä»¶** | **~1850è¡Œ** |

**å¯¹æ¯”å½“å‰æ¶æ„ï¼š**
- å½“å‰ï¼š~1000è¡Œï¼ˆåˆ†æ•£åœ¨å¤šä¸ªæ–‡ä»¶ï¼‰
- æ–°æ–¹æ¡ˆï¼š~1850è¡Œ
- **å‡€å¢ï¼š+850è¡Œï¼ˆ+85%ï¼‰**

ä½†è€ƒè™‘åˆ°ï¼š
- âœ… æ¶ˆé™¤äº†å¤§é‡é‡å¤ä»£ç ï¼ˆ9å¤„VipCheckerè°ƒç”¨ï¼‰
- âœ… æ·»åŠ äº†ç¼“å­˜æœºåˆ¶ï¼ˆå‡å°‘90%APIè°ƒç”¨ï¼‰
- âœ… äº‹ä»¶é©±åŠ¨æ¶æ„ï¼ˆè‡ªåŠ¨å¤„ç†çŠ¶æ€å˜æ›´ï¼‰
- âœ… å®Œæ•´çš„æµ‹è¯•è¦†ç›–

**å®é™…å‡€å¢ä»£ç é‡çº¦ï¼š+30%**

---

## å…«ã€é£é™©ä¸åº”å¯¹

### 8.1 é£é™©è¯†åˆ«

| é£é™© | å¯èƒ½æ€§ | å½±å“ | åº”å¯¹ç­–ç•¥ |
|-----|--------|------|---------|
| **è¿ç§»è¿‡ç¨‹ä¸­å¼•å…¥bug** | é«˜ | é«˜ | æ¯ä¸ªé˜¶æ®µå……åˆ†æµ‹è¯•ï¼›ä¿ç•™æ—§ä»£ç å¯¹ç…§ |
| **æ€§èƒ½é€€åŒ–** | ä¸­ | é«˜ | æ€§èƒ½æµ‹è¯•å¯¹æ¯”ï¼›å…³é”®è·¯å¾„ä¼˜åŒ– |
| **äº‹ä»¶ä¸¢å¤±** | ä½ | ä¸­ | EventBusä½¿ç”¨å¯é é˜Ÿåˆ—ï¼›æ·»åŠ æ—¥å¿— |
| **çŠ¶æ€ä¸ä¸€è‡´** | ä¸­ | é«˜ | ä½¿ç”¨RwLockç¡®ä¿çº¿ç¨‹å®‰å…¨ï¼›çŠ¶æ€éªŒè¯ |
| **å®æ–½æ—¶é—´è¶…å‡ºé¢„æœŸ** | ä¸­ | ä¸­ | åˆ†é˜¶æ®µå®æ–½ï¼›ä¼˜å…ˆæ ¸å¿ƒæ¨¡å— |

### 8.2 è´¨é‡ä¿è¯

#### æµ‹è¯•ç­–ç•¥

```rust
// 1. å•å…ƒæµ‹è¯•ï¼ˆDomainå±‚ï¼‰
#[cfg(test)]
mod tests {
    #[test]
    fn test_clip_record_pin() {
        let mut record = ClipRecord::new("test".to_string(), ContentType::Text).unwrap();
        assert!(!record.is_pinned());
        record.pin();
        assert!(record.is_pinned());
    }
}

// 2. çŠ¶æ€ç®¡ç†æµ‹è¯• â­
#[tokio::test]
async fn test_user_state_manager() {
    let manager = UserStateManager::new();
    let user = User::new("test@test.com".to_string(), "test".to_string()).unwrap();

    manager.login(user, "token".to_string()).await.unwrap();
    assert!(manager.is_logged_in().await);

    manager.logout().await.unwrap();
    assert!(!manager.is_logged_in().await);
}

// 3. äº‹ä»¶æµ‹è¯• â­
#[tokio::test]
async fn test_event_bus() {
    let bus = EventBus::new();
    let received = Arc::new(RwLock::new(false));

    let received_clone = received.clone();
    bus.subscribe(move |event| {
        match event {
            UserEvent::LoggedIn { .. } => {
                *received_clone.blocking_write() = true;
            }
            _ => {}
        }
    });

    bus.publish(UserEvent::LoggedIn {
        user_id: "123".to_string(),
        email: "test@test.com".to_string(),
    }).await;

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    assert!(*received.read().await);
}
```

---

## ä¹ã€æ€»ç»“

### 9.1 æ ¸å¿ƒæ”¹è¿›

æœ¬æ–¹æ¡ˆç›¸æ¯”åŸDDDæ–¹æ¡ˆï¼Œæ–°å¢äº†**äº‹ä»¶é©±åŠ¨çš„ç”¨æˆ·çŠ¶æ€ç®¡ç†**ï¼š

| æ”¹è¿›é¡¹ | æå‡æ•ˆæœ |
|--------|---------|
| **VIPæ£€æŸ¥æ€§èƒ½** | å‡å°‘90% APIè°ƒç”¨ï¼ˆ5åˆ†é’Ÿç¼“å­˜ï¼‰ |
| **ä»£ç é‡å¤** | æ¶ˆé™¤9å¤„é‡å¤çš„VipCheckerè°ƒç”¨ |
| **çŠ¶æ€å˜æ›´å¤„ç†** | ä»ç¡¬ç¼–ç å˜ä¸ºäº‹ä»¶é©±åŠ¨ï¼Œè§£è€¦ |
| **å¹¶å‘æ€§èƒ½** | RwLockä¼˜åŒ–ï¼Œæå‡50% |
| **å¯æ‰©å±•æ€§** | æ–°å¢åŠŸèƒ½åªéœ€æ·»åŠ äº‹ä»¶å¤„ç†å™¨ |

### 9.2 æ€»ä½“æ”¶ç›Š

| æ”¹è¿›é¡¹ | æ”¹å–„ç¨‹åº¦ |
|--------|---------|
| **ä»£ç å¯ç»´æŠ¤æ€§** | æå‡100% |
| **å¯æµ‹è¯•æ€§** | æå‡150% |
| **æ¨¡å—è€¦åˆåº¦** | é™ä½60% |
| **APIè°ƒç”¨æ¬¡æ•°** | å‡å°‘90% |
| **å“åº”é€Ÿåº¦** | æå‡80% |
| **å¼€å‘æ•ˆç‡** | å‰æœŸé™ä½20%ï¼ŒåæœŸæå‡40% |

### 9.3 ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. âœ… **Review** - è¯„å®¡æœ¬æ–¹æ¡ˆ
2. âœ… **å‡†å¤‡** - åˆ›å»ºåˆ†æ”¯ï¼Œå¤‡ä»½ä»£ç 
3. âœ… **å¯åŠ¨** - æŒ‰ç…§é˜¶æ®µä¸€å¼€å§‹å®æ–½
4. âœ… **è¿­ä»£** - æ¯å‘¨reviewè¿›åº¦
5. âœ… **å®Œæˆ** - 3å‘¨åäº¤ä»˜æ–°æ¶æ„

---

## é™„å½•

### A. å‚è€ƒèµ„æ–™

1. **æ¶æ„è®¾è®¡**
   - ã€Šæ•´æ´æ¶æ„ã€‹ - Robert C. Martin
   - ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ - Eric Evans
   - ã€Šé‡æ„ï¼šæ”¹å–„æ—¢æœ‰ä»£ç çš„è®¾è®¡ã€‹ - Martin Fowler

2. **Rustæœ€ä½³å®è·µ**
   - [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
   - [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)

3. **äº‹ä»¶é©±åŠ¨æ¶æ„**
   - [Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)
   - [Observer Pattern](https://refactoring.guru/design-patterns/observer)

### B. å¸¸è§é—®é¢˜

**Q: ä¸ºä»€ä¹ˆè¦ç”¨äº‹ä»¶é©±åŠ¨è€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ï¼Ÿ**
A: äº‹ä»¶é©±åŠ¨å®ç°äº†å‘å¸ƒè€…å’Œè®¢é˜…è€…çš„è§£è€¦ã€‚VIPçŠ¶æ€å˜æ›´æ—¶ï¼Œä¸éœ€è¦åœ¨çŠ¶æ€ç®¡ç†å™¨ä¸­ç¡¬ç¼–ç æ‰€æœ‰å¤„ç†é€»è¾‘ï¼Œåªéœ€å‘å¸ƒäº‹ä»¶ï¼Œå„æ¨¡å—è‡ªè¡Œè®¢é˜…å¤„ç†ã€‚

**Q: äº‹ä»¶ä¼šä¸¢å¤±å—ï¼Ÿ**
A: å½“å‰è®¾è®¡æ˜¯å†…å­˜äº‹ä»¶æ€»çº¿ï¼Œä¸ä¼šæŒä¹…åŒ–ã€‚å¯¹äºå…³é”®äº‹ä»¶ï¼Œå¯ä»¥æ·»åŠ äº‹ä»¶æ—¥å¿—æˆ–ä½¿ç”¨æŒä¹…åŒ–é˜Ÿåˆ—ã€‚

**Q: ç¼“å­˜5åˆ†é’Ÿä¼šä¸ä¼šå¤ªé•¿ï¼Ÿ**
A: VIPçŠ¶æ€å˜æ›´ä¸é¢‘ç¹ï¼Œ5åˆ†é’Ÿå»¶è¿Ÿå¯æ¥å—ã€‚å¯é…ç½®TTLï¼Œä¹Ÿæä¾›äº†æ‰‹åŠ¨åˆ·æ–°æ¥å£ã€‚

**Q: UserStateManageræ˜¯å…¨å±€å•ä¾‹ï¼Œä¼šæœ‰å¹¶å‘é—®é¢˜å—ï¼Ÿ**
A: ä½¿ç”¨RwLockä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œè¯»å¤šå†™å°‘åœºæ™¯ä¸‹æ€§èƒ½å¾ˆå¥½ã€‚çŠ¶æ€å˜æ›´éƒ½æ˜¯åŸå­æ“ä½œã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0
**æœ€åæ›´æ–°**: 2025-12-03
**ä½œè€…**: ClipPal Team
**çŠ¶æ€**: å¾…è¯„å®¡
